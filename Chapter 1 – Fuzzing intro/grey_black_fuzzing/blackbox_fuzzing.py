#!/usr/bin/env python3
# -*- coding: utf-8 -*-


import random
from fuzzingbook.Coverage import Coverage, population_coverage

from fuzzingbook.MutationFuzzer import FunctionCoverageRunner



def crashme (s):
    if             len(s) > 0 and s[0] == 'b':
        if         len(s) > 1 and s[1] == 'a':
            if     len(s) > 2 and s[2] == 'd':
                if len(s) > 3 and s[3] == '!':
                    raise Exception()

crashme_runner = FunctionCoverageRunner(crashme)
crashme_runner.run("good")
list(crashme_runner.coverage())

# ## Blackbox Fuzzing

from fuzzingbook.Fuzzer import Fuzzer

class MutationFuzzer(Fuzzer):
    
    def __init__(self, seeds, mutator, schedule):
        self.seeds = seeds
        self.mutator = mutator
        self.schedule = schedule
        self.inputs = []
        self.reset()

    def reset(self):
        """Reset the initial population and seed index"""
        self.population = list(map(lambda x: Seed(x), self.seeds))
        self.seed_index = 0

    def create_candidate(self):
        """Returns an input generated by fuzzing a seed in the population"""
        seed = self.schedule.choose(self.population)

        # Stacking: Apply multiple mutations to generate the candidate
        candidate = seed.data
        trials = min(len(candidate), 1 << random.randint(1,5))
        for i in range(trials):
            candidate = self.mutator.mutate(candidate)
        return candidate

    def fuzz(self):
        """Returns first each seed once and then generates new inputs"""
        if self.seed_index < len(self.seeds):
            # Still seeding
            self.inp = self.seeds[self.seed_index]
            self.seed_index += 1
        else:
            # Mutating
            self.inp = self.create_candidate()
            
        self.inputs.append(self.inp)
        return self.inp
    

if __name__ == "__main__":
    seed_input = "good"
    mutation_fuzzer = MutationFuzzer([seed_input], Mutator(), PowerSchedule())
    print(mutation_fuzzer.fuzz())
    print(mutation_fuzzer.fuzz())
    print(mutation_fuzzer.fuzz())


import time
n = 30000

if __name__ == "__main__":
    blackbox_fuzzer = MutationFuzzer([seed_input], Mutator(), PowerSchedule())

    start = time.time()
    blackbox_fuzzer.runs(FunctionCoverageRunner(crashme), trials=n)
    end = time.time()



from fuzzingbook.Coverage import population_coverage

if __name__ == "__main__":
    _, blackbox_coverage = population_coverage(blackbox_fuzzer.inputs, crashme)


if __name__ == "__main__":
    print([seed_input] + \
    [blackbox_fuzzer.inputs[idx] for idx in range(len(blackbox_coverage)) 
        if blackbox_coverage[idx] > blackbox_coverage[idx - 1]
    ])
    
    print(blackbox_fuzzer.population)

    
    
